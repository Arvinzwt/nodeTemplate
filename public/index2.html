<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        video {
            vertical-align: top;
            background: #ccc;
        }
    </style>
</head>
<body>
    <div id="app">
        <button onclick="openWebRTC()">开始</button>
        <button onclick="closeWebRTC()">结束</button>
        <video id="oVideo1" autoplay></video>
        <video id="oVideo2" autoplay></video>
    </div>
</body>
<script>
    let subscriberPeerConnection = null;
    let publisherPeerConnection = null;
    let localStream = null;

    // 开始
    function openWebRTC() {
        console.log("拉取摄像头权限")
        navigator.mediaDevices.getUserMedia({
            audio: true,
            video: {
                width: {exact: 720},
                height: {exact: 405}
            }
        }).then((stream) => {
            console.log('拉取摄像头权限成功')
            console.log('摄像头数据流放入视频1')
            document.getElementById('oVideo1').srcObject = localStream = stream;//摄像头1

            createSubscriber();//建立连接
            createPublisher();//建立连接
        }).catch(function (error) {
            console.log('拉取摄像头权限失败', err)
        });
    }


    // 建立连接
    function createSubscriber() {
        console.log('创建本地计算机到远端的WebRTC连接1')
        subscriberPeerConnection = new RTCPeerConnection({"iceServers": [{"urls": "stun:stun.l.google.com:19302"}]})


        subscriberPeerConnection.ontrack = function (event) {
            console.log('远端的WebRTC连接1 触发的轨道事件')
            console.log('远端的WebRTC连接1 数据流放入视频2')
            document.getElementById('oVideo2').srcObject = event.streams[0];
        }

        // 当获得新的源之后，需要将该源的信息发送给远端信号服务器，并分发至其他端的RTCPeerConnection。其他RTCPeerConnection通过addIceCandidate()方法将新candidate 中携带的信息，将新的源描述信息添加进它的备选池中；
        subscriberPeerConnection.onicecandidate = function (event) {
            console.log('远端的WebRTC连接1 添加新的RTCICECandidate对象')

            if (publisherPeerConnection) {
                console.log('远端的WebRTC连接2 将远端的WebRTC连接1 添加的candidate中携带的信息，将新的源描述信息添加进它的备选池中')

                publisherPeerConnection.addIceCandidate(event.candidate).then(() => {
                    console.log('添加成功');
                }).catch(function (error) {
                    console.log('添加失败');
                });
            }
        }
    }

    // 建立接受者连接
    function createPublisher() {
        console.log('创建本地计算机到远端的WebRTC连接2')
        publisherPeerConnection = new RTCPeerConnection({"iceServers": [{"urls": "stun:stun.l.google.com:19302"}]})

        console.log('将视频1中轨道信息全部添加到远端的WebRTC连接2')
        localStream.getTracks().forEach((track) => {
            publisherPeerConnection.addTrack(track, localStream);
        });

        publisherPeerConnection.onicecandidate = function (event) {
            console.log('远端的WebRTC连接2 添加新的RTCICECandidate对象')

            if (subscriberPeerConnection) {
                console.log('远端的WebRTC连接1 将远端的WebRTC连接2 添加的candidate中携带的信息，将新的源描述信息添加进它的备选池中')

                subscriberPeerConnection.addIceCandidate(event.candidate).then(() => {
                    console.log('添加成功');
                }).catch(function (error) {
                    console.log('添加成功');
                });
            }
        }

        console.log('远端的WebRTC连接2 启动创建一个SDP offer')
        publisherPeerConnection.createOffer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: true
        }).then((desc) => {
            // 更改与连接关联的本地描述。此描述指定连接本地端的属性，包括媒体格式
            console.log('远端的WebRTC连接1和远端的WebRTC连接2 更改与连接关联的本地描述,保持与新建的SDP offe一致')
            publisherPeerConnection.setLocalDescription(desc);
            subscriberPeerConnection.setRemoteDescription(desc);

            subscriberPeerConnection.createAnswer().then((desc2) => {
                subscriberPeerConnection.setLocalDescription(desc2);
                publisherPeerConnection.setRemoteDescription(desc2);
            }).catch(function (error) {
            });
        }).catch(function (error) {
        });
    }

    function closeWebRTC() {
        localStream.getTracks().forEach(track => {
            track.stop();
        });
        publisherPeerConnection.close();
        subscriberPeerConnection.close();
    }
</script>
</html>